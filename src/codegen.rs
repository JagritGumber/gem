//! Rust Code Generator
//! Emits zero-heap Rust source from SceneIR using typed property structs

use crate::ir::{NodeId, SceneIR};
use std::collections::HashMap;

pub struct RustCodegen {
    output: String,
    indent_level: usize,
}

impl RustCodegen {
    pub fn new() -> Self {
        Self {
            output: String::new(),
            indent_level: 0,
        }
    }

    pub fn generate(mut self, scene: &SceneIR) -> String {
        self.emit_header();
        self.emit_property_structs(scene);
        self.emit_node_structs(scene);
        self.emit_scene_struct(scene);
        self.emit_builder(scene);
        self.emit_helpers(scene);
        self.output
    }
    fn emit_header(&mut self) {
        self.writeln("// Auto-generated by Gem compiler");
        self.writeln("// Do not edit manually\n");
        self.writeln("#![allow(unused)]\n");
    }

    /// Generate a struct for each node's properties with typed fields
    fn emit_property_structs(&mut self, scene: &SceneIR) {
        let mut ids: Vec<NodeId> = scene.nodes.keys().cloned().collect();
        ids.sort_by_key(|id| id.0);

        for id in ids.iter() {
            let node = &scene.nodes[id];
            if node.properties.is_empty() {
                continue;
            }

            // Generate struct name from node name
            let struct_name = format!("{}Props", node.name);

            self.writeln(&format!("#[derive(Debug, Clone)]"));
            self.writeln(&format!("pub struct {} {{", struct_name));
            self.indent();

            // Emit fields with inferred types
            for (key, typed_prop) in node.properties.iter() {
                let rust_type = typed_prop.prop_type.to_rust_type();
                self.writeln(&format!("pub {}: {},", key, rust_type));
            }

            self.dedent();
            self.writeln("}\n");

            // Emit const instance
            self.writeln(&format!(
                "pub const {}_PROPS: {} = {} {{",
                node.name.to_uppercase(),
                struct_name,
                struct_name
            ));
            self.indent();

            for (key, typed_prop) in node.properties.iter() {
                let const_value = typed_prop.prop_type.parse_to_rust_const(&typed_prop.value);
                self.writeln(&format!("{}: {},", key, const_value));
            }

            self.dedent();
            self.writeln("};\n");
        }
    }

    /// Generate node structs that reference their property structs
    fn emit_node_structs(&mut self, scene: &SceneIR) {
        let mut ids: Vec<NodeId> = scene.nodes.keys().cloned().collect();
        ids.sort_by_key(|id| id.0);

        self.writeln("#[derive(Debug)]");
        self.writeln("pub struct Node {");
        self.indent();
        self.writeln("pub name: &'static str,");
        self.writeln("pub class_name: &'static str,");
        self.writeln("pub node_index: usize,");
        self.dedent();
        self.writeln("}\n");

        // Create node instances
        for (idx, id) in ids.iter().enumerate() {
            let node = &scene.nodes[id];
            let const_name = format!("{}_NODE", node.name.to_uppercase());

            self.writeln(&format!("pub const {}: Node = Node {{", const_name));
            self.indent();
            self.writeln(&format!("name: \"{}\",", node.name));
            self.writeln(&format!("class_name: \"{}\",", node.class_name));
            self.writeln(&format!("node_index: {},", idx));
            self.dedent();
            self.writeln("};\n");
        }

        // Create children index lists
        self.writeln("// Children adjacency lists");
        for id in ids.iter() {
            let node = &scene.nodes[id];
            let child_indices: Vec<String> =
                node.children.iter().map(|cid| cid.0.to_string()).collect();
            self.writeln(&format!(
                "pub const {}_CHILDREN: &[usize] = &[{}];",
                node.name.to_uppercase(),
                child_indices.join(", ")
            ));
        }
        self.writeln("");
    }

    fn emit_scene_struct(&mut self, scene: &SceneIR) {
        let mut ids: Vec<NodeId> = scene.nodes.keys().cloned().collect();
        ids.sort_by_key(|id| id.0);

        self.writeln("#[derive(Debug)]");
        self.writeln("pub struct Scene {");
        self.indent();
        self.writeln("pub root_index: usize,");
        self.writeln("pub node_count: usize,");
        self.dedent();
        self.writeln("}\n");

        self.writeln("pub const SCENE: Scene = Scene {");
        self.indent();
        let root_idx = scene.root.map(|r| r.0).unwrap_or(0);
        self.writeln(&format!("root_index: {},", root_idx));
        self.writeln(&format!("node_count: {},", ids.len()));
        self.dedent();
        self.writeln("};\n");
    }

    fn emit_builder(&mut self, scene: &SceneIR) {
        let mut ids: Vec<NodeId> = scene.nodes.keys().cloned().collect();
        ids.sort_by_key(|id| id.0);

        self.writeln("pub fn build_scene() -> Scene {");
        self.indent();
        self.writeln("SCENE");
        self.dedent();
        self.writeln("}\n");
    }

    fn emit_helpers(&mut self, scene: &SceneIR) {
        let mut ids: Vec<NodeId> = scene.nodes.keys().cloned().collect();
        ids.sort_by_key(|id| id.0);

        // Generate node name -> index lookup
        self.writeln("pub fn find_node_by_name(name: &str) -> Option<usize> {");
        self.indent();
        self.writeln("match name {");
        self.indent();
        for (idx, id) in ids.iter().enumerate() {
            let node = &scene.nodes[id];
            self.writeln(&format!("\"{}\" => Some({}),", node.name, idx));
        }
        self.writeln("_ => None,");
        self.dedent();
        self.writeln("}");
        self.dedent();
        self.writeln("}\n");

        // Generate typed property accessor example
        self.writeln("// Example: Access typed properties");
        self.writeln("// let title_text = TITLE_PROPS.text;");
        self.writeln("// let button_pos = STARTBUTTON_PROPS.position;");
    }

    fn indent(&mut self) {
        self.indent_level += 1;
    }
    fn dedent(&mut self) {
        if self.indent_level > 0 {
            self.indent_level -= 1;
        }
    }
    fn writeln(&mut self, line: &str) {
        if !line.is_empty() {
            self.output.push_str(&"    ".repeat(self.indent_level));
            self.output.push_str(line);
        }
        self.output.push('\n');
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::SceneIR;

    #[test]
    fn codegen_simple_scene() {
        let mut scene = SceneIR::new();
        let r = scene.add_node("Root", "Gem");
        let c = scene.add_node("Child", "Sprite");
        scene.add_child(r, c);
        scene.set_property(r, "position", "(0, 0)");

        let code = RustCodegen::new().generate(&scene);
        // Check for typed property structs
        assert!(code.contains("pub struct RootProps"));
        assert!(code.contains("pub const ROOT_PROPS"));
        assert!(code.contains("pub position: (i32, i32)"));
        // Check for node constants
        assert!(code.contains("pub const ROOT_NODE: Node"));
        assert!(code.contains("pub const CHILD_NODE: Node"));
        // Check for scene and builder
        assert!(code.contains("pub const SCENE: Scene"));
        assert!(code.contains("pub fn build_scene() -> Scene"));
        // Check node names present
        assert!(code.contains("Root"));
        assert!(code.contains("Child"));
    }
}
